实验目的：
实现一个程序，执行格式为：./proc command1 … commandn
作用是在参数中指定的程序之间创建管道并执行这些程序

实验原理：
循环的为两个程序之间创建管道并执行前一个程序：

+-------------+-------------+-------------+-------------+
|       p1    |       p2    |       ….    |       pn    |
+-------------+-------------+-------------+-------------+
              ①             ②             ③
主进程会fork出一个子进程：
主进程：为自己的标准输出创建管道并连到写端，主进程的工作已完成，可以将自己替换为p1并执行
子进程：将自己的标准输入连到主进程创建的管道的读端
此时①处应做的操作已经完成，p2相当于p1，可以循环执行
在③处的管道创建完成之后，就只需要将当前进程替换为pn并执行

测试：
有三个程序用于测试：
a：分别向标准输出输出三个字符ABC，并在输出之间睡眠一段时间以便观察
b：从标准输入循环读取字符并随即向标准输出输出字符
c：从标准输入循环读取字符并随即向标准输出输出字符
为得到三个进程每一步操作的顺序，在每一次写字符和读字符的时候都获取当前系统的时间并通过标准错误流输出

实验结果：
#write time 1544673891.433610#

#inter time 1544673891.589610#

#read time 1544673891.592173#
>Read>>
#read time 1544673891.595636#
I
#read time 1544673891.596860#
n
#read time 1544673891.598782#
t
#read time 1544673891.602652#
e
#read time 1544673891.603777#
r
#read time 1544673891.604423#
>
#read time 1544673891.606588#
A
#write time 1544673893.435466#

#inter time 1544673893.439350#

#read time 1544673893.441641#
B
#write time 1544673895.440165#

#inter time 1544673895.443178#

#read time 1544673895.445848#
C
#write time 1544673900.444004#

可以很明显的看出，进程在运行期间通过管道交流，而不是后一个进程等待前一个执行结束之后才可以开始执行

注意事项：
在测试程序中执行输出的时候，需要在输出之后fflush()一下，否则输出的内容可能会被暂时缓冲起来而不立即输出，造成前一个程序执行结束后面的程序才能读到的假象。进程的缓冲策略可以被设置。

